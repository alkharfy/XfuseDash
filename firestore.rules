/**
 * @fileOverview Firestore Security Rules for the marketing team dashboard.
 *
 * Core Philosophy:
 * This ruleset enforces a user-ownership model for user profiles and notifications,
 * combined with role-based access control for clients and system logs. The rules leverage
 * denormalized data (e.g., `registeredBy` and `assignedToPR` on clients) to ensure
 * authorization independence and efficient rule evaluation.
 *
 * Data Structure:
 * - /users/{userId}: Stores user profiles, with access restricted to the owning user.
 * - /clients/{clientId}: Stores client data, with access control based on user roles and
 *   the `registeredBy` and `assignedToPR` fields.
 * - /notifications/{notificationId}: Stores user-specific notifications.
 * - /systemLogs/{logId}: Stores system logs, with write access limited to authorized users.
 *
 * Key Security Decisions:
 * - User data is private and only accessible to the owning user.
 * - Client data access is role-based, allowing specific roles to create, update, or delete clients.
 * - Notifications are user-specific and only accessible to the owning user.
 * - System logs are append-only and restricted to authorized users.
 *
 * Denormalization for Authorization:
 * - The `clients` collection includes `registeredBy` and `assignedToPR` fields to avoid
 *   costly `get()` operations when validating user roles and client ownership.
 *
 * Structural Segregation:
 * - Different entities (users, clients, notifications, system logs) are stored in separate
 *   collections to simplify security rules and ensure a homogeneous security posture for each collection.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    /**
     * @description Controls access to user profiles.
     * @path /users/{userId}
     * @allow (create) - Authenticated user can create their own profile (userId in path must match auth.uid).
     * @allow (get, update, delete) - Authenticated user can only access their own profile.
     * @deny (create) - If userId in path does not match auth.uid.
     * @deny (list) - Listing users is not allowed.
     * @principle Enforces user-ownership: users can only read/write their own data.
     */
    match /users/{userId} {
      function isOwner(userId) {
        return request.auth.uid == userId;
      }

      function isSignedIn() {
        return request.auth != null;
      }

      allow get: if isOwner(userId);
      allow list: if false;
      allow create: if isSignedIn() && isOwner(userId);
      allow update: if isSignedIn() && isOwner(userId);
      allow delete: if isSignedIn() && isOwner(userId);
    }

    /**
     * @description Controls access to client data.
     * @path /clients/{clientId}
     * @allow (create) - Only users with the 'admin' or 'moderator' role can create clients.
     *                    The 'registeredBy' field must match the creating user's ID.
     * @allow (get, list) - All authenticated users can read client data.
     * @allow (update, delete) - Only users with the 'admin' role or the user who registered the client can update or delete it.
     * @deny (create) - If the 'registeredBy' field does not match the creating user's ID.
     * @principle Enforces role-based access control and data ownership.
     */
    match /clients/{clientId} {
      function isAdmin() {
        return get(/databases/$(database)/documents/users/$(request.auth.uid)).data.role == 'admin';
      }

      function isModerator() {
        return get(/databases/$(database)/documents/users/$(request.auth.uid)).data.role == 'moderator';
      }

      function isOwner(registeredBy) {
          return request.auth.uid == registeredBy;
      }

      function isSignedIn() {
        return request.auth != null;
      }

      allow get, list: if true;
      allow create: if isSignedIn() && (isAdmin() || isModerator()) && request.resource.data.registeredBy == request.auth.uid;
      allow update: if isSignedIn() && (isAdmin() || isOwner(resource.data.registeredBy));
      allow delete: if isSignedIn() && (isAdmin() || isOwner(resource.data.registeredBy));
    }

    /**
     * @description Controls access to user-specific notifications.
     * @path /notifications/{notificationId}
     * @allow (create) - Not allowed. Notifications should only be created via backend functions.
     * @allow (get, list) - Only the user the notification belongs to can read it.
     * @allow (update, delete) - Not allowed. Notifications cannot be updated or deleted by the client.
     * @deny (create, update, delete) - All client-side writes are denied.
     * @principle Enforces strict user-ownership and read-only access from the client.
     */
    match /notifications/{notificationId} {
       function isOwner(userId) {
         return request.auth.uid == userId;
       }

       function isSignedIn() {
         return request.auth != null;
       }

        allow get, list: if isSignedIn() && isOwner(resource.data.userId);
        allow create: if false;
        allow update: if false;
        allow delete: if false;
    }

    /**
     * @description Controls access to system logs.
     * @path /systemLogs/{logId}
     * @allow (create) - Only users with the 'admin' role can create system logs.
     * @allow (get, list) - All authenticated users can read system logs.
     * @allow (update, delete) - Not allowed. System logs are append-only.
     * @deny (update, delete) - All client-side updates and deletes are denied.
     * @principle Enforces role-based access control and append-only logging.
     */
    match /systemLogs/{logId} {
      function isAdmin() {
        return get(/databases/$(database)/documents/users/$(request.auth.uid)).data.role == 'admin';
      }

      function isSignedIn() {
        return request.auth != null;
      }

      allow get, list: if true;
      allow create: if isSignedIn() && isAdmin();
      allow update: if false;
      allow delete: if false;
    }
  }
}