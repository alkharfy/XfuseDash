/**
 * @file Firebase Security Rules for the Marketing Team Dashboard
 *
 * Core Philosophy:
 * This ruleset enforces a role-based access control model with ownership checks to secure data access.
 * Users can only manage their own user document. Clients can be managed by assigned moderators and PR personnel.
 * System Logs can be created by anyone but are not editable or deletable, and they can only be read by admins.
 * Notifications are restricted to their owning user.
 *
 * Data Structure:
 * - /users/{userId}: Stores user profiles, including roles.
 * - /clients/{clientId}: Stores client data, with fields for assigned moderator (`moderatorId`) and PR (`assignedToPR`) personnel to enable role-based access.
 * - /notifications/{notificationId}: Stores notification data.
 * - /systemLogs/{logId}: Stores system logs.
 *
 * Key Security Decisions:
 * - User listing is disabled.
 * - Roles are stored directly in the user document for simplicity and performance.
 * - The transferStatus field on the /clients/{clientId} collection can be modified by the assignedToPR.
 *
 * Denormalization for Authorization:
 * - The `clients` collection denormalizes the `registeredBy` and `assignedToPR` fields to enable authorization checks without needing to query the `/users` collection. This significantly improves rule performance and prevents costly `get()` operations.
 *
 * Structural Segregation:
 * - User data, client data, notifications, and system logs are stored in separate top-level collections. This segregation simplifies security rules and ensures a clear security posture for each data type.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    /**
     * @description: Manages user profiles, restricting access based on the user's identity.
     * @path: /users/{userId}
     * @allow: (create) User 'user_abc' can create their own user document if request.auth.uid == 'user_abc'.
     * @deny: (create) User 'user_xyz' cannot create a user document with ID 'user_abc'.
     * @principle: Enforces user ownership and prevents unauthorized user creation.
     */
    match /users/{userId} {
      // Verifies that the user is signed in.
      function isSignedIn() {
        return request.auth != null;
      }

      // Checks if the user ID matches the authenticated user's ID.
      function isOwner(userId) {
        return request.auth.uid == userId;
      }

      // Allows a user to create their own document.
      allow create: if isSignedIn() && isOwner(userId) && request.resource.data.id == request.auth.uid;

      // Allows a user to get their own document.
      allow get: if isSignedIn() && isOwner(userId);

      // Allows a user to update their own document. Enforces immutability for the user ID.
      allow update: if isSignedIn() && isOwner(userId) && request.resource.data.id == resource.data.id;

      // Allows a user to delete their own document.
      allow delete: if isSignedIn() && isOwner(userId);

      // User listing is not permitted
      allow list: if false;
    }

    /**
     * @description: Manages client data, restricting access based on the assigned moderator, assigned PR representative and the registering user.
     * @path: /clients/{clientId}
     * @allow: (create) A moderator 'user_abc' can create a client and assign themselves by setting request.resource.data.registeredBy == 'user_abc'.
     * @deny: (create) A user 'user_xyz' cannot create a client and assign the moderator as 'user_abc'.
     * @principle: Enforces client ownership by moderator and restricts unauthorized client creation.
     */
    match /clients/{clientId} {
      // Verifies that the user is signed in.
      function isSignedIn() {
        return request.auth != null;
      }

      // Get user role from users collection
      function getUserRole() {
        return get(/databases/$(database)/documents/users/$(request.auth.uid)).data.role;
      }

      // Check if the user is the assigned PR representative
      function isAssignedPR() {
        return isSignedIn() && (request.resource.data.assignedToPR == request.auth.uid);
      }

      // Check if the user is the client's assigned moderator
      function isClientModerator() {
          return isSignedIn() && (request.resource.data.moderatorId == request.auth.uid);
      }

      // Check if user is market researcher
      function isMarketResearcher() {
        return isSignedIn() && getUserRole() == 'market_researcher';
      }

      // Check if user is creative
      function isCreative() {
        return isSignedIn() && getUserRole() == 'creative';
      }

      // Check if user is content
      function isContent() {
        return isSignedIn() && getUserRole() == 'content';
      }

      // Anyone can read clients
      allow get, list: if true;

      // A user can create a client document if they are the registering user.
      allow create: if isSignedIn() && request.resource.data.registeredBy == request.auth.uid;

      // Allows the assigned PR representative to update the transferStatus field.
      // Prevents modification of other fields.
      allow update: if isAssignedPR();

      // Allows the assigned moderator to update other client properties
      allow update: if isClientModerator();

      // Allows market researcher to update marketResearchFiles field
      allow update: if isMarketResearcher();

      // Allows creative to update creative-related fields
      allow update: if isCreative();

      // Allows content to update content-related fields
      allow update: if isContent();

      // Only allow the registering user to delete the client
      allow delete: if isSignedIn() && resource.data.registeredBy == request.auth.uid;
    }

    /**
     * @description: Manages notifications, restricting access to the owning user.
     * @path: /notifications/{notificationId}
     * @allow: (create) User 'user_abc' can create a notification for themselves by setting request.resource.data.userId == 'user_abc'.
     * @deny: (create) User 'user_xyz' cannot create a notification for user 'user_abc'.
     * @principle: Enforces notification ownership and prevents unauthorized notification creation.
     */
    match /notifications/{notificationId} {
      // Verifies that the user is signed in.
      function isSignedIn() {
        return request.auth != null;
      }

      // Checks if the user ID matches the authenticated user's ID.
      function isOwner() {
        return request.auth.uid == request.resource.data.userId;
      }

      // Allows a user to read notification documents.
      allow get, list: if isSignedIn() && request.auth.uid == resource.data.userId;

      // Only allow creation if the userId matches the request.auth.uid
      allow create: if isSignedIn() && isOwner();

      // Only allow the user to update the notification, if the userId matches the request.auth.uid
      allow update: if isSignedIn() && isOwner();

      // Only allow the user to delete the notification, if the userId matches the request.auth.uid
      allow delete: if isSignedIn() && resource.data.userId == request.auth.uid;
    }

    /**
     * @description: Manages system logs, allowing creation by any authenticated user but restricting read access to administrators.
     * @path: /systemLogs/{logId}
     * @allow: (create) Any signed-in user can create a system log.
     * @deny: (get, list) Non-admin users cannot read system logs.
     * @principle: Enables auditing by allowing any user to create logs, but restricts access to sensitive log data.
     */
    match /systemLogs/{logId} {
      // Verifies that the user is signed in.
      function isSignedIn() {
        return request.auth != null;
      }

      // Checks if the user has the 'admin' role.
      function isAdmin() {
        return isSignedIn() && get(/databases/$(database)/documents/users/$(request.auth.uid)).data.role == 'admin';
      }

      // Anyone can create system logs.
      allow create: if isSignedIn();

      // Only admins can read logs.
      allow get, list: if isAdmin();

      // No one can update system logs.
      allow update: if false;

      // No one can delete system logs.
      allow delete: if false;
    }
  }
}